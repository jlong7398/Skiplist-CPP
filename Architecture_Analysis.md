# Skiplist-CPP 项目架构分析文档

## 1. 项目概述

### 1.1 项目名称与目标
**项目名称**: Skiplist-CPP
**项目目标**: 构建一个基于 **跳表 (SkipList)** 数据核心结构的高性能、线程安全、支持持久化的轻量级键值型 (KV) 存储引擎。该项目旨在展示现代 C++ (C++20) 的工程实践、并发编程技术以及存储引擎的基本设计原理。

### 1.2 核心功能
*   **键值存储**: 提供基础的 `put` (增/改)、`get` (查)、`del` (删) 接口。
*   **并发访问**: 支持多线程环境下的高并发读写操作（读写锁机制）。
*   **数据持久化**: 支持内存数据到磁盘文件的自动转储 (Dump) 和启动时加载 (Load)。
*   **泛型支持**: 核心数据结构采用模板设计，支持任意可比较的键类型和可序列化的值类型。

---

## 2. 架构设计

### 2.1 整体架构图

项目采用分层架构设计，各层职责清晰，这也是存储系统的经典设计模式。

```ascii
+-------------------------------------------------------+
|                   应用层 (User Application)           |
|  main.cpp / stress_test.cpp / User Custom Code        |
+---------------------------+---------------------------+
                            | 调用接口
                            v
+-------------------------------------------------------+
|                   接口层 (Interface Layer)            |
|                  KVStore.h (封装类)                   |
|  - 自动持久化管理 (Dump/Load)                         |
|  - 简单的 CRUD 接口封装                               |
+---------------------------+---------------------------+
                            | 持有实例
                            v
+-------------------------------------------------------+
|                   核心引擎层 (Core Engine)            |
|                  SkipList.h (跳表实现)                |
|  - 插入 / 删除 / 查找 算法逻辑                        |
|  - 线程安全控制 (std::shared_mutex)                   |
|  - 概率性层级生成 (Random Level)                      |
+---------------------------+---------------------------+
                            | 包含
                            v
+-------------------------------------------------------+
|                   基础数据层 (Data Layer)             |
|                   Node.h (节点定义)                   |
|  - 泛型 Key/Value 存储                                |
|  - 多层级指针管理 (std::vector forward_)              |
+-------------------------------------------------------+
                            | 文件 I/O
                            v
+-------------------------------------------------------+
|                   持久化存储 (Storage)                |
|                   Disk File (store/dumpFile)          |
+-------------------------------------------------------+
```

### 2.2 模块划分与依赖关系

1.  **Node (基础模块)**:
    *   定义了跳表的最基本单元。
    *   **依赖**: STL (`vector`)。
2.  **SkipList (核心模块)**:
    *   实现了跳表的具体逻辑，管理 Node 的组织方式。
    *   **依赖**: `Node`, 线程同步库 (`shared_mutex`, `mutex`)。
3.  **KVStore (服务模块)**:
    *   对外提供统一的服务接口，负责生命周期管理（如启动加载、由于 RAII 机制的自动落盘）。
    *   **依赖**: `SkipList`, 文件流库 (`fstream`)。
4.  **Client (应用模块)**:
    *   `main.cpp` 和 `stress_test.cpp`，负责实例化 KVStore 并发起请求。
    *   **依赖**: `KVStore`。

---

## 3. 核心组件分析

### 3.1 `Node.h` (数据节点)
*   **职责**: 存储实际的键值对数据，以及指向后续节点的指针数组（跳表的索引层）。
*   **设计亮点**:
    *   使用 `std::vector<Node*>` 管理 `forward_` 指针，相比传统的 `Node**` 二级指针更安全，自动管理内存释放，避免了手动 `delete[]` 的风险。
    *   这是一个纯模板类，本身不包含复杂的业务逻辑。

### 3.2 `SkipList.h` (核心数据结构)
*   **职责**: 维护跳表的拓扑结构，提供线程安全的 CRUD 原子操作。
*   **关键实现**:
    *   **`insert_element`**: 使用 `update` 数组记录每层的前驱节点，确保链表插入的原子性。使用 `std::unique_lock` 实现写互斥。
    *   **`search_element`**: 从最高层逐层下沉查找。使用 `std::shared_lock` 实现读共享，允许多个线程同时查询，极大提升读性能。
    *   **`delete_element`**: 同样使用 `update` 数组定位前驱，调整指针指向。使用 `std::unique_lock`。
    *   **内存管理**: 析构函数 `~SkipList()` 负责遍历整个链表通过 `delete` 释放所有 `Node` 内存，防止内存泄漏。
    *   **`process_all`**: 提供一个遍历接口（接受回调函数），允许上层模块（如持久化模块）高效遍历所有数据而无需暴露内部指针。

### 3.3 `KVStore.h` (存储引擎封装)
*   **职责**: 将跳表包装为成熟的 KV 存储产品，添加了持久化能力。
*   **关键实现**:
    *   **RAII 持久化**:
        *   **构造 (`load`)**: 初始化时读取磁盘文件，解析每行数据并插入跳表。
        *   **析构 (`dump`)**: 程序退出（对象销毁）时，自动遍历跳表将数据写入磁盘。
    *   **序列化协议**: 目前采用简单的文本协议 `key:value\n`。
    *   **类型适配**: 在 `load` 时对不同类型的 Value (如 `std::string` vs `int`) 进行了基本的解析处理（使用 `if constexpr` 优化）。

---

## 4. 技术选型与决策

### 4.1 为什么选择跳表 (SkipList)?
*   **实现简单**: 相比红黑树或 B+ 树，跳表的代码实现复杂度低，且易于调试。
*   **并发优势**: 跳表的局部性锁或无锁实现相比平衡树更容易（虽然本项目主要使用粗粒度锁，但跳表结构本身对并发友好）。
*   **性能均衡**: 提供 $O(\log N)$ 的平均时间复杂度，满足 KV 存储的高性能需求。

### 4.2 为什么使用 `std::shared_mutex`?
*   **读写分离场景**: KV 存储通常是 **读多写少** 的场景。
*   **性能最大化**: `shared_lock` (读锁) 允许多个线程同时读取，只有在写入时才需要 `unique_lock` (写锁) 独占。这比使用普通的 `std::mutex`（完全互斥）在读密集型负载下有显著的性能提升。

### 4.3 为什么使用 Header-Only 设计?
*   **易于集成**: 整个库由几个头文件组成 (`.h`)，用户只需 `#include` 即可使用，无需复杂的链接步骤。
*   **模板实例化**: C++ 模板类必须在头文件中定义实现，这与泛型设计天然契合。

---

## 5. 项目目录结构说明

```text
Skiplist-CPP/
├── .vscode/               # VSCode 编辑器配置
├── include/               # [核心] 头文件目录
│   ├── Node.h             # 节点类模板定义
│   ├── SkipList.h         # 跳表核心算法实现
│   └── KVStore.h          # 存储引擎封装层
├── stress-test/           # [测试] 压力测试
│   └── stress_test.cpp    # 多线程并发测试源文件
├── store/                 # [数据] 数据持久化目录
│   └── dumpFile           # 默认的数据落盘文件
├── build/                 # [构建] CMake 构建输出目录
├── main.cpp               # [示例] 功能演示的主程序
├── CMakeLists.txt         # [构建] 项目构建脚本
├── README.md              # 项目文档
├── Learning_Plan.md       # 学习计划记录
└── stress_test_start.sh   # (已废弃) 旧的 Shell 测试脚本，建议使用 CMake 编译测试
```

---

## 6. 总结
本项目通过精简的代码实现了一个具备工业级雏形的 KV 存储引擎。架构设计遵循了高内聚、低耦合的原则，将数据结构、线程安全控制和持久化逻辑进行了合理的分离，为后续的功能扩展（如更复杂的序列化、网络服务接口等）奠定了良好的基础。
